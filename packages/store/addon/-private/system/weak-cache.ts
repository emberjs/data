import { DEBUG } from '@glimmer/env';

import { DEBUG_IDENTIFIER_BUCKET } from '../ts-interfaces/identifier';

/*
  DEBUG only fields. Keeping this in a separate interface
  which Typescript then merges with the class definition allow us to
  have a DEBUG only property without paying the cost of that field being
  present and initialized (usually to void 0) in production.
*/
interface WeakCache<K extends object, V> extends WeakMap<K, V> {
  _symbol: Symbol;
  _fieldName: string;
  _expectMsg?: (key: K) => string;
  /*
    The default Typescript Signature for WeakMap expects obj: K and
    returns a boolean. This behavior isn't useful in our common case
    where we want to use `has` to narrow by determining whether a
    particular object is a key.

    For instance, we use WeakMap key check to determine in some cases
    whether an object given to us by a user is a RecordIdentifier or
    a Record.
  */
  has(obj: unknown): obj is K;

  /*
    This is an exception to the interface being used for
    DEBUG ony fields. In this case, only a few WeakCache's
    will utilize the lookup behavior, so paying the cost in
    the constructor signature / field initialization seemed
    off.
  */
  _generator?: (key: K) => V;
}

/**
 * @class WeakCache
 * @extends WeakMap
 * @internal
 */
class WeakCache<K extends object, V> extends WeakMap<K, V> {
  constructor(_fieldName: string) {
    super();
    if (DEBUG) {
      this._fieldName = _fieldName;
      this._symbol = Symbol.for(_fieldName);
    }
  }

  /**
   * Retrieve the value for a key from the WeakCache with the expectation
   * that the key exists. Throws the error generated by _expectMsg in DEBUG if
   * that key does not exist.
   *
   * @method getWithError
   * @param obj
   * @internal
   */
  getWithError(obj: K): V {
    let v = this.get(obj);

    if (DEBUG && v === undefined) {
      throw new Error(this._expectMsg!(obj));
    }

    return v as V;
  }

  /**
   * Retrieve the value for a key from the WeakCache, or generate one
   * using the configured _generator method if no value is yet present.
   *
   * @method lookup
   * @param obj
   * @internal
   */
  lookup(obj: K): V {
    let v = super.get(obj);

    if (v === undefined) {
      v = this._generator!(obj);
      super.set(obj, v);

      if (DEBUG) {
        if (obj[DEBUG_IDENTIFIER_BUCKET] && this._fieldName !== 'identifier-proxy-target') {
          const target: K = obj[Symbol.for('identifier-proxy-target') as unknown as string] as K;
          target[this._symbol as unknown as string] = v;
        } else {
          obj[this._symbol as unknown as string] = v;
        }
      }
    }

    return v;
  }
}

class DebugWeakCache<K extends object, V> extends WeakCache<K, V> {
  set(obj: K, value: V): this {
    if (DEBUG && super.has(obj)) {
      throw new Error(`${Object.prototype.toString.call(obj)} was already assigned a value for ${this._fieldName}`);
    }
    if (DEBUG) {
      if (obj[DEBUG_IDENTIFIER_BUCKET] && this._fieldName !== 'identifier-proxy-target') {
        const target: K = obj[Symbol.for('identifier-proxy-target') as unknown as string] as K;
        target[this._symbol as unknown as string] = value;
        // TODO the Proxy check here is entirely for ember-m3
        // as it's attribute access tests fail since the symbol
        // is an unexpected key received by it's proxies.
        // we should address this upstream.
      } else if (obj.constructor?.toString?.() !== 'MegamorphicModel') {
        try {
          obj[this._symbol as unknown as string] = value;
        } catch {
          // some keys are proxies that can't accept symbol values
          // for instance records from ember-m3
        }
      }
    }
    return super.set(obj, value);
  }
}
export type { DebugWeakCache };
export default DEBUG ? DebugWeakCache : WeakCache;
