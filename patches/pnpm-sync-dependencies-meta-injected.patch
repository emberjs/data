diff --git a/src/index.js b/src/index.js
index 30744e751c0a964a7c2efd5c7fce63ce14544ad6..1c3670d625ead98dc5af425c641b7c2c7f26ee58 100644
--- a/src/index.js
+++ b/src/index.js
@@ -14,6 +14,78 @@ import Watcher from 'watcher';
 const debug = Debug('sync-pnpm');
 const DEBOUNCE_INTERVAL = 50;
 
+/**
+ * @param {String} root
+ */
+async function getNPMRC(root) {
+  const npmrcPath = join(root, '.npmrc');
+
+  let npmrc;
+
+  try {
+    npmrc = await fs.readFile(npmrcPath, 'utf8');
+  } catch {
+    throw new Error(`Could not read .npmrc file at ${npmrcPath}`);
+  }
+
+  const lines = npmrc.split('\n');
+
+  /** @type {Record<string,string|boolean|string[]>} */
+  const config = {};
+
+  for (const line of lines) {
+    if (!line || line.startsWith('#')) {
+      continue;
+    }
+
+    if (line.indexOf('=') === -1) {
+      continue;
+    }
+
+    /** @type {string|undefined} */
+    let key;
+
+    /** @type {string|boolean|undefined} */
+    let value;
+
+    [key, value] = line.split('=');
+    if (!value || !key) {
+      continue;
+    }
+
+    if (value.indexOf(' ') !== -1) {
+      value = value.split(' ')[0];
+    }
+
+    if (value === 'true') {
+      value = true;
+    } else if (value === 'false') {
+      value = false;
+    }
+
+    if (key.endsWith('[]')) {
+      let values = config[key];
+      if (!values) {
+        values = config[key] = [];
+      }
+
+      if (!Array.isArray(values)) {
+        throw new Error('Expected value to be an array');
+      }
+
+      if (typeof value !== 'string') {
+        throw new Error('Expected value to be a string');
+      }
+
+      values.push(value);
+    } else {
+      config[key] = value;
+    }
+  }
+
+  return config;
+}
+
 /**
  * @typedef {object} Options
  * @property {string} directory working directory
@@ -28,9 +100,16 @@ export default async function syncPnpm(options) {
   debug(`--watch=${watch}`);
   debug(`--directory=${dir}`);
 
-  const packagesToSync = await getPackagesToSync(dir);
+  const root = await findWorkspaceDir(dir);
+  if (!root) {
+    throw new Error(`Could not find workspace root`);
+  }
+  const npmrc = await getNPMRC(root);
+  const packages = await findWorkspacePackages(root);
+
+  const packagesToSync = await getPackagesToSync(dir, packages, npmrc);
 
-  if (!packagesToSync) {
+  if (!packagesToSync || packagesToSync.length === 0) {
     debug(
       `Found 0 packages to sync. Did you forget dependenciesMeta.*.injected?`
     );
@@ -167,40 +246,47 @@ async function isFile(filePath) {
 
 /**
  * @param {string} dir the current working directory or the directory of a project
+ * @param {Awaited<ReturnType<typeof findWorkspacePackages>>} localProjects
+ * @param {Record<string,string|boolean|string[]>} npmrc
  */
-async function getPackagesToSync(dir) {
-  const root = await findWorkspaceDir(dir);
-
-  if (!root) {
-    throw new Error(`Could not find workspace root`);
-  }
-
+async function getPackagesToSync(dir, localProjects, npmrc) {
+  const isInGlobalInjectMode = npmrc['inject-workspace-packages'];
   const localManifestPath = path.join(dir, 'package.json');
   const ownProject = await readExactProjectManifest(localManifestPath);
-  const injectedDependencyNames = injectedDeps(ownProject);
 
-  /**
-   * If dependencies are not injected, we don't need to re-link
-   */
-  if (!injectedDependencyNames || injectedDependencyNames?.size === 0) {
-    return;
-  }
+  return isInGlobalInjectMode ? injectedDeps(ownProject, localProjects) : workspaceDeps(ownProject, localProjects);
+}
 
-  const localProjects = await findWorkspacePackages(root);
+/**
+ * @typedef {Awaited<ReturnType<typeof readExactProjectManifest>>} Project
+ *
+ * @param {Project} project
+ * @param {Awaited<ReturnType<typeof findWorkspacePackages>>} localProjects
+ */
+function workspaceDeps(project, localProjects) {
+  const foundDeps = [];
+  for (let workspaceProject of localProjects) {
+    if (!workspaceProject.manifest.name) {
+      continue;
+    }
 
-  return localProjects.filter((p) => {
-    if (!p.manifest.name) return false;
+    if (project.manifest.dependencies?.[workspaceProject.manifest.name]) {
+      foundDeps.push(workspaceProject);
+    } else if (project.manifest.devDependencies?.[workspaceProject.manifest.name]) {
+      foundDeps.push(workspaceProject);
+    } else if (project.manifest.peerDependencies?.[workspaceProject.manifest.name]) {
+      foundDeps.push(workspaceProject);
+    }
+  }
 
-    return injectedDependencyNames.has(p.manifest.name);
-  });
+  return foundDeps;
 }
 
 /**
- * @typedef {Awaited<ReturnType<typeof readExactProjectManifest>>} Project
- *
  * @param {Project} project
+ * @param {Awaited<ReturnType<typeof findWorkspacePackages>>} localProjects
  */
-function injectedDeps(project) {
+function injectedDeps(project, localProjects) {
   const ownPackageJson = project.manifest;
 
   let depMeta = ownPackageJson.dependenciesMeta;
@@ -215,7 +301,18 @@ function injectedDeps(project) {
     }
   }
 
-  return injectedDependencyNames;
+  /**
+   * If dependencies are not injected, we don't need to re-link
+   */
+  if (!injectedDependencyNames || injectedDependencyNames?.size === 0) {
+    return;
+  }
+
+  return localProjects.filter((p) => {
+    if (!p.manifest.name) return false;
+
+    return injectedDependencyNames.has(p.manifest.name);
+  });
 }
 
 /**
