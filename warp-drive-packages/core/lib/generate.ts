/**
 * This script is used to generate re-exports for all of the modules in the packages
 * provided by EmberData/WarpDrive, as well as to generate the `exports` manifest
 * for them in package.json.
 *
 * It additionally ensures that type declarations are auto-discoverable by consuming
 * projects by adding in the appropriate `types` field to the `exports` manifest in
 * package.json.
 */
import * as parser from '@babel/parser';
import traverse from '@babel/traverse';
import fs from 'fs';
import { Mappings } from './mappings';

const _traverse = (traverse as unknown as { default: typeof traverse }).default;

const PKG = JSON.parse(fs.readFileSync('../package.json', 'utf8'));
const EXPORTS = (PKG.exports = {
  '.': {
    default: './do-not-import-me.js',
  },
});

function primaryModuleName(moduleName: string) {
  const parts = moduleName.split('/').slice(0, 2);
  return parts.join('/');
}

// function generateTypeManifest() {
// 	const references = [
// 		`// These references are autogenerated by @auditboard/warp-drive`,
// 		`// They are used to ensure that type declarations from EmberData/WarpDrive`,
// 		`// are available for use by consuming projects.`,
// 	];

// 	Mappings.v0.forEach((pkg) => {
// 		references.push(`/// <reference path="./v0/${pkg}/index.d.ts" />`);
// 	});

// 	Mappings.v1.forEach((pkg) => {
// 		references.push(`/// <reference path="./v1/${pkg}/index.d.ts" />`);
// 	});

// 	Mappings.v2.forEach((pkg) => {
// 		references.push(`/// <reference path="./v2/${pkg}/index.d" />`);
// 	});
// }
function excludeTypeReferenceFor(pkgName) {
  return Mappings.excludeTypes.includes(pkgName);
}
function rootReferencesFor(relative, version) {
  if (version === 'v0') {
    const v0 = Mappings.v0.map((pkg) => (excludeTypeReferenceFor(pkg) ? null : `${relative}${pkg}/index.d.ts`));
    const v1 = Mappings.v1.map((pkg) => (excludeTypeReferenceFor(pkg) ? null : `../${relative}v1/${pkg}/index.d.ts`));

    return [...v0, ...v1].filter(Boolean).map((path) => `/// <reference path="${path}" />`);
  }

  if (version === 'v1') {
    const v0 = Mappings.v0.map((pkg) => (excludeTypeReferenceFor(pkg) ? null : `../${relative}v0/${pkg}/index.d.ts`));
    const v1 = Mappings.v1.map((pkg) => (excludeTypeReferenceFor(pkg) ? null : `${relative}${pkg}/index.d.ts`));
    return [...v0, ...v1].filter(Boolean).map((path) => `/// <reference path="${path}" />`);
  }

  return Mappings.v2
    .map((pkg) => (excludeTypeReferenceFor(pkg) ? null : `${relative}${pkg}/index.d.ts`))
    .filter(Boolean)
    .map((path) => `/// <reference path="${path}" />`);
}

function tryThrow<T>(fn: () => T, error: string) {
  try {
    return fn();
  } catch (e) {
    throw new Error(error, { cause: e });
  }
}

function moduleNameFor(pkgName: keyof typeof Mappings, filePath: string) {
  let modulePath = filePath.replace('.js', '').replace('.d.ts', '');
  if (modulePath.startsWith('/')) {
    modulePath = modulePath.slice(1);
  }
  if (modulePath.endsWith('index')) {
    modulePath = modulePath.slice(0, -5);
  }
  if (modulePath.endsWith('/')) {
    modulePath = modulePath.slice(0, -1);
  }

  return modulePath ? `${pkgName}/${modulePath}` : pkgName;
}

interface ExportToken {
  name: string;
  importedName: string | null;
  type: 'all' | 'default' | string;
  kind?: string;
  from: string | null;
}

function collectExportsFromAST(ast: parser.ParseResult, log = false) {
  const EXPS: ExportToken[] = [];

  _traverse(ast, {
    ExportAllDeclaration(nodePath) {
      EXPS.push({
        name: '*',
        importedName: '*',
        type: 'all',
        from: nodePath.node.source.value,
      });
      if (log) {
        // eslint-disable-next-line no-console
        console.log('ExportAllDeclaration', EXPS.at(-1));
        // eslint-disable-next-line no-console
        console.log(nodePath.node);
        // eslint-disable-next-line no-console
        console.log('\n\n');
      }
    },
    ExportDefaultDeclaration(nodePath) {
      EXPS.push({
        name: 'default',
        importedName: null,
        type: 'default',
        from: null,
      });
      if (log) {
        // eslint-disable-next-line no-console
        console.log('ExportDefaultDeclaration', EXPS.at(-1));
        // eslint-disable-next-line no-console
        console.log(nodePath.node);
        // eslint-disable-next-line no-console
        console.log('\n\n');
      }
    },
    ExportNamedDeclaration(nodePath) {
      if (nodePath.node.declaration) {
        let kind = nodePath.node.declaration.kind ? nodePath.node.declaration.kind : nodePath.node.declaration.type;
        const inferredExportKind = kind === 'TSTypeAliasDeclaration' ? 'type' : null;
        if (kind === 'FunctionDeclaration') {
          kind = 'function';
        }

        if (nodePath.node.declaration.declarations) {
          for (const decl of nodePath.node.declaration.declarations) {
            EXPS.push({
              name: decl.id.name,
              importedName: null,
              type: kind,
              kind:
                inferredExportKind || nodePath.node.declaration.exportKind === 'type'
                  ? 'type'
                  : decl.exportKind || 'value',
              from: null,
            });
            if (log) {
              // eslint-disable-next-line no-console
              console.log('ExportNamedDeclaration', EXPS.at(-1));
              // eslint-disable-next-line no-console
              console.log(decl);
              // eslint-disable-next-line no-console
              console.log(nodePath.node.declaration);
              // eslint-disable-next-line no-console
              console.log('\n\n');
            }
          }
          return;
        }

        EXPS.push({
          name: nodePath.node.declaration.id.name,
          importedName: null,
          type: kind,
          kind: inferredExportKind || nodePath.node.declaration.exportKind || 'value',
          from: null,
        });

        if (log) {
          // eslint-disable-next-line no-console
          console.log('ExportNamedDeclaration', EXPS.at(-1));
          // eslint-disable-next-line no-console
          console.log(nodePath.node.declaration);
          // eslint-disable-next-line no-console
          console.log('\n\n');
        }
        return;
      }
      if (!nodePath.node.specifiers) {
        throw new Error('Unknown export syntax');
      }
      for (const specifier of nodePath.node.specifiers) {
        EXPS.push({
          name: specifier.exported.name,
          importedName: nodePath.node.source ? specifier.local.name : null,
          type: 'named',
          kind: nodePath.node.exportKind === 'type' ? 'type' : specifier.exportKind,
          from: (nodePath.node.source && nodePath.node.source.value) || null,
        });
        if (log) {
          // eslint-disable-next-line no-console
          console.log('ExportNamedDeclaration', EXPS.at(-1));
          // eslint-disable-next-line no-console
          console.log(specifier);
          // eslint-disable-next-line no-console
          console.log(nodePath.node);
          // eslint-disable-next-line no-console
          console.log('\n\n');
        }
      }
    },
  });

  return dedupeExports(EXPS);
}

function dedupeExports(EXPS) {
  const seen = new Map();
  for (const exp of EXPS) {
    if (seen.has(exp.name)) {
      // update if kind switches from type to value
      const current = seen.get(exp.name);
      if (current.kind === 'type' && exp.kind === 'value') {
        seen.set(exp.name, exp);
      }
      continue;
    }
    seen.set(exp.name, exp);
  }

  return [...seen.values()];
}

/**
 * Processes the fileContents of <moduleName> to find its exports, and generates
 * a JS file at outFilePath that re-exports all exports from the module.
 */
async function generateJSReExportFile(fileContents: string, moduleName: string, outFilePath: string) {
  const ast = parser.parse(fileContents, {
    sourceType: 'module',
  });
  const EXPS = collectExportsFromAST(ast);
  const exportString: string[] = [];

  // re-export all exported tokens
  const tokens: string[] = [];
  for (const exp of EXPS) {
    if (exp.type === 'all') {
      if (tokens.length) {
        exportString.push(`export { ${tokens.join(', ')} } from '${moduleName}';`);
        tokens.length = 0;
      }
      exportString.push(`export * from '${exp.from}';`);
      continue;
    }
    tokens.push(exp.name);
  }
  if (tokens.length) {
    exportString.push(`export { ${tokens.join(', ')} } from '${moduleName}';`);
  }

  // copy over all doc comments

  const newFile = [
    `//`,
    `// This file was programmatically generated by @warp-drive/core`,
    `// It re-exports all of the exports from the source module ${moduleName}`,
    `//`,
    `// Types are re-exported in a different file in /types`,
    `//`,
    exportString.join('\n'),
    '',
  ].join('\n');

  const outDir = outFilePath.split('/').slice(0, -1).join('/');
  fs.mkdirSync(outDir, { recursive: true });
  fs.writeFileSync(outFilePath, newFile, { encoding: 'utf8' });
}

/**
 * Generates the type declaration for our JS file above, it does so from
 * the types source not the JS source by design, so actual exports may differ.
 */
function generateTypeReExportFile(fileContents, moduleName, outFilePath, version) {
  const outDir = outFilePath.split('/').slice(0, -1).join('/');

  const ast = tryThrow(
    () =>
      parser.parse(fileContents, {
        sourceType: 'module',
        allowUndeclaredExports: true,
        plugins: [['typescript', { dts: true }]],
      }),
    `[@auditboard/warp-drive generate] Failed to parse type file for ${moduleName}`
  );
  const EXPS = collectExportsFromAST(ast);
  const exportString = [];
  const tokens = [];
  for (const exp of EXPS) {
    if (exp.type === 'all') {
      if (tokens.length) {
        exportString.push(`export { ${tokens.join(', ')} } from '${moduleName}';`);
        tokens.length = 0;
      }
      exportString.push(exp.kind === 'type' ? `export type * from '${exp.from}';` : `export * from '${exp.from}';`);
      continue;
    }
    tokens.push(exp.kind === 'type' ? `type ${exp.name}` : exp.name);
  }
  if (tokens.length) {
    exportString.push(`export { ${tokens.join(', ')} } from '${moduleName}';`);
  }

  const parts = moduleName.split('/');
  let relativePrefix = '../';

  if (parts.length > 2) {
    relativePrefix = '../'.repeat(parts.length - 2);
  }

  const newFile = [
    `//`,
    `// This file was programmatically generated by @auditboard/warp-drive`,
    `// It re-exports all of the exports from the d.ts declaration for ${moduleName}`,
    `//`,
    `// These types may not reflect the actual exports as they are generated from`,
    `// latest canary releases of the source modules.`,
    `//`,
    `// If you discover an issue, please report it to the @api-contracts team`,
    `//`,
    rootReferencesFor(relativePrefix, version).join('\n'),
    exportString.join('\n'),
    '',
  ].join('\n');

  fs.mkdirSync(outDir, { recursive: true });
  fs.writeFileSync(outFilePath, newFile, { encoding: 'utf8' });
}

type PkgJson = {
  name: string;
  exports: Record<string, string>;
};

function getPkgJson(dependencyName: keyof typeof Mappings) {
  const packagePath = `./node_modules/${dependencyName}/package.json`;
  return tryThrow<PkgJson>(
    () => JSON.parse(fs.readFileSync(packagePath, 'utf8')),
    `[@warp-drive/core generate] Failed to read package.json for ${dependencyName}`
  );
}

function makeTypesPackageName(dependencyName) {
  const [scope, name] = dependencyName.split('/');
  return `${scope}-types/${name}`;
}

function makeDestDirName(name: keyof typeof Mappings) {
  const config = Mappings[name];
  return `../dist/${config.dir}`;
}

function makeTypeDestDirName(name: keyof typeof Mappings) {
  const config = Mappings[name];
  return `../types/${config.dir}`;
}

function generateReExportsForPackage(pkg, destDir, version) {
  const sourceDir = tryThrow(() => {
    if (fs.existsSync(`./node_modules/${pkg.name}/dist`)) {
      return { source: `./node_modules/${pkg.name}/dist`, type: 'dist' };
    }
    if (fs.existsSync(`./node_modules/${pkg.name}/addon`)) {
      return { source: `./node_modules/${pkg.name}/addon`, type: 'addon' };
    }
    throw new Error('No source directory found');
  }, `[@auditboard/warp-drive generate] Failed to find sourcecode directory for ${pkg.name}`);

  const files = tryThrow(
    () => fs.readdirSync(sourceDir.source, { recursive: true }),
    `Error scanning sourcecode directory ${sourceDir.source}`
  );
  files.forEach((filePath) => {
    if (!filePath.endsWith('.js')) {
      return;
    }
    const fullPath = `${sourceDir.source}/${filePath}`;
    const outPath = `${destDir}/${filePath}`;

    // parse the file for export statements and generate re-exports
    generateJSReExportFile(fs.readFileSync(fullPath, 'utf8'), moduleNameFor(pkg.name, filePath), outPath);
  });

  if (Mappings.excludeTypes.includes(pkg.name)) {
    return;
  }

  // we generate the type declarations for the re-exported files
  const typesPackageName = makeTypesPackageName(pkg.name);
  const hasTypesPkgDeclared = PKG.dependencies[typesPackageName] || PKG.devDependencies[typesPackageName];
  const typeSourceDir = tryThrow(() => {
    const nativePkgLocation = `./node_modules/${pkg.name}/unstable-preview-types`;
    if (fs.existsSync(nativePkgLocation)) {
      return { source: nativePkgLocation, type: 'native' };
    }

    // if no native types exist and we don't have a types package
    // then nothing more to do.
    if (!hasTypesPkgDeclared) {
      return null;
    }

    const typesPkgLocation = `./node_modules/${typesPackageName}/unstable-preview-types`;
    if (fs.existsSync(typesPkgLocation)) {
      return { source: typesPkgLocation, type: 'canary-types' };
    }
  }, `[@auditboard/warp-drive generate] Failed to find type directory for ${pkg.name}`);

  if (!typeSourceDir) {
    // eslint-disable-next-line no-console
    console.warn(
      `Skipping type generation for ${pkg.name} as no declarations were discovered and it has no types package installed`
    );
    return;
  }

  EXPORTS[exportName] = {
    types: `./declarations/${version}/${name}/index.d.ts`,
    default: `./dist/${version}/${name}/index${ending}`,
  };
  EXPORTS[`./${version}/${name}/*`] = {
    types: `./declarations/${version}/${name}/*.d.ts`,
    default: `./dist/${version}/${name}/*${ending}`,
  };

  const typeDestDir = makeTypeDestDirName(pkg.name, version);
  const typesPkg = hasTypesPkgDeclared ? getPkg(typesPackageName) : pkg;

  const typeFiles = tryThrow(
    () => fs.readdirSync(typeSourceDir.source, { recursive: true }),
    `Error scanning type directory ${typeSourceDir.source}`
  );

  typeFiles.forEach((filePath) => {
    if (!filePath.endsWith('.d.ts')) {
      return;
    }
    const fullPath = `${typeSourceDir.source}/${filePath}`;
    const outPath = `${typeDestDir}/${filePath}`;

    // parse the module def for export statements and generate re-exports
    generateTypeReExportFile(fs.readFileSync(fullPath, 'utf8'), moduleNameFor(pkg.name, filePath), outPath, version);
  });

  generateTypesForPackage(pkg, version, typesPkg);
}

function generateTypesForPackage(pkg, version, typesPkg) {
  const rootTypesDir = `./declarations/${version}`;
  const sourceDir = `./node_modules/${typesPkg.name}/unstable-preview-types`;
  const libDestDir = `${rootTypesDir}/${pkg.name}`;

  // we recursively copy all the declaration files into the libDestDir
  // it is a requirement that every types package has an index.d.ts file
  fs.mkdirSync(libDestDir, { recursive: true });
  fs.cpSync(sourceDir, libDestDir, { recursive: true });
}

async function generateFilesForPackage(rootPkg: PkgJson, name: keyof typeof Mappings) {
  const pkg = getPkgJson(name);
  const config = Mappings[name];
  const destDir = makeDestDirName(name);
  const sourceDir = tryThrow(() => {
    if (fs.existsSync(`./node_modules/${pkg.name}/dist`)) {
      return { source: `./node_modules/${pkg.name}/dist`, type: 'dist' };
    }
    throw new Error('No source directory found');
  }, `[@warp-drive/core generate] Failed to find sourcecode directory for ${pkg.name}`);
  const files = tryThrow(
    () => fs.readdirSync(sourceDir.source, { recursive: true }) as string[],
    `[@warp-drive/core generate] Error scanning sourcecode directory ${sourceDir.source}`
  );

  // for each module in the package
  // => we want to generate re-exports for all the exports
  // => we want to rename inline API documentation
  // => we want to generate the types for all the exports
  for (const filePath of files) {
    if (!filePath.endsWith('.js')) {
      // ignore .js.map files and other non-js files
      continue;
    }

    const fullPath = `${sourceDir.source}/${filePath}`;
    const outPath = `${destDir}/${filePath}`;

    // parse the file for export statements and generate re-exports
    await generateJSReExportFile(fs.readFileSync(fullPath, 'utf8'), moduleNameFor(name, filePath), outPath);
  }

  generateReExportsForPackage(pkg, destDir, config);
}

async function processPackages(packages: typeof Mappings): Promise<PkgJson> {
  const keys = Object.keys(packages) as (keyof typeof Mappings)[];
  const pkg = JSON.parse(fs.readFileSync('../package.json', 'utf8'));

  for (const key of keys) {
    await generateFilesForPackage(pkg, key);
  }

  return pkg;
}

async function main() {
  // clean before generate
  if (fs.existsSync('../dist')) {
    fs.rmSync('../dist', { recursive: true });
  }

  if (fs.existsSync('../types')) {
    fs.rmSync('../types', { recursive: true });
  }

  // generate :)
  const PKG = await processPackages(Mappings);

  // add addon-main to exports
  PKG.exports['./addon-main.js'] = './addon-main.cjs';

  fs.writeFileSync('../package.json', JSON.stringify(PKG, null, 2) + '\n');
}

main();
